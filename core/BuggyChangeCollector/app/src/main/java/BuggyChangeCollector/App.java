/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package BuggyChangeCollector;

import org.apache.commons.cli.*;
import java.io.*;
import java.util.*;
import com.opencsv.CSVWriter;

// import org.slf4j.Logger;
// import org.slf4j.LoggerFactory;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.core.config.Configurator;

public class App {
    public static boolean isDebugging = false; // TODO: Implement verbose output option.

    private String hashID = new String();
    private boolean isDefects4j = false;
    
    private String bugInfoFile = new String();

    private String projectName = new String();
    private String projectLink = new String();
    private String faultyPath = new String();
    private int faultyLineFix = 0;
    private int faultyLineBlame = 0;
    
    private static final Logger logger = LogManager.getLogger(App.class);
    // private static final Logger logger = Logger.getRootLogger();

    public static void main(String[] args) {
        Configurator.setLevel(App.class, Level.INFO);

        App main = new App();
        main.run(args);
    }

    public void run(String[] args)
    {
        Properties bugProps = new Properties();

        String root = System.getProperty("user.dir");

        Project targetProject;

        parseArgs(args);

        System.out.printf("Configuration file set as %s\n", System.getProperty("log4j.configurationFile"));

        String targetDir = String.format("%s/target/%s", root, hashID);
        String outputDir = String.format("%s/outputs", targetDir);
        String BCCDir = String.format("%s/BuggyChangeCollector", outputDir);
        File targetDirPath = new File(targetDir);
        File outputDirPath = new File(outputDir);
        File BCCDirPath = new File(BCCDir);

        boolean isFailing = true;
        if(!targetDirPath.isDirectory())    isFailing = targetDirPath.mkdirs();
        if(!outputDirPath.isDirectory())    isFailing = outputDirPath.mkdirs();
        if(!BCCDirPath.isDirectory())       isFailing = BCCDirPath.mkdirs();

        if(!isFailing)
        {
            System.err.println("mkdirs for target/output directory failed.");
            System.exit(-1);
        }

        targetProject = (isDefects4j)   ? (new Defects4JProject(this.projectName, targetDir))
                                        : (new GitHubProject(this.projectName, this.projectLink, targetDir, this.faultyPath, this.faultyLineBlame, this.faultyLineFix));

        targetProject.fetch();

        String[] FICs = targetProject.getFICs(); // {BFIC, FIC}

        logger.info(String.format("BFIC ID extracted as %s", FICs[0]));
        logger.info(String.format(" FIC ID extracted as %s", FICs[1]));

        System.out.printf("BFIC : %s\n", FICs[0]);
        System.out.printf("FIC : %s\n", FICs[1]);

        try
        {
            CSVWriter writer = new CSVWriter(new FileWriter(String.format("%s//BFIC.csv", BCCDir)));
            String[] headers = "Project,D4J ID,Faulty file path,faulty line,FIC_sha,BFIC_sha".split(",");
            String[] entries = {targetProject.getProjectName(), String.format("%d", targetProject.getIdentifier()), targetProject.getFaultyPath(), String.format("%d", targetProject.getFaultyLineFix()), FICs[1], FICs[0]};
            writer.writeNext(headers);
            writer.writeNext(entries);
            writer.close();
        }
        catch(IOException ex)
        {
            ex.printStackTrace();
            System.exit(-1);
        }
    }

    public void parseArgs(String[] args)
    {
        Options options = new Options();
        Option[] option = new Option[5];
        String root = System.getProperty("user.dir");

        option[0] = Option.builder("d").longOpt("defects4j")
            .hasArg().argName("defects4jBug")
            .desc("Tells that Defects4J Bug is passed as an argument.").build();
        option[1] = Option.builder("i").longOpt("input")
            .hasArg().argName("directInput")
            .desc("Tells that direct input is given in one line, separated in comma.").build();
        option[2] = Option.builder("f").longOpt("file")
            .hasArg().argName("bugInfoFile")
            .desc("Tells that defect properties are directly given via .properties file.").build();
        option[3] = Option.builder("h").longOpt("hash")
            .required()
            .hasArg().argName("hashID")
            .desc("Tells that previously made byproducts will be used.").build();
        option[4] = Option.builder("?").longOpt("help")
            .desc("Prints out this help message.").build();

        for(int i = 0; i < option.length; i++)  options.addOption(option[i]);

        CommandLineParser parser = new DefaultParser();
        try
        {
            CommandLine line = parser.parse(options, args);

            if(line.hasOption("help"))
            {
                HelpFormatter formatter = new HelpFormatter();
                formatter.printHelp("BuggyChangeCollector", options);

                System.exit(0);
            }

            if(line.hasOption("hash")) this.hashID = line.getOptionValue("hash");
            if(line.hasOption("file"))
            {
                this.bugInfoFile = line.getOptionValue("file");
                
                Properties bugProps = new Properties();
                bugProps.load(new FileInputStream(bugInfoFile));

                this.projectName        = bugProps.getProperty("projectName");
                this.projectLink        = bugProps.getProperty("projectLink");
                this.faultyPath         = bugProps.getProperty("faultyPath");
                this.faultyLineBlame    = Integer.parseInt(bugProps.getProperty("faultyLineBlame"));
                this.faultyLineFix      = Integer.parseInt(bugProps.getProperty("faultyLineFix"));
            }
            if(line.hasOption("input"))
            {
                String[] bugInfo = line.getOptionValue("input").split(",");

                this.projectName        = bugInfo[0];
                this.projectLink        = bugInfo[1];
                this.faultyPath         = bugInfo[2];
                this.faultyLineBlame    = Integer.parseInt(bugInfo[3]);
                this.faultyLineFix      = Integer.parseInt(bugInfo[4]);
            }
            if(line.hasOption("defects4j"))
            {
                this.projectName = line.getOptionValue("defects4j");
                this.isDefects4j = true;
            }
        }
        catch (ParseException | IOException ex)
        {
            System.err.println("Parsing failed. Reason: " + ex.getMessage());
            ex.printStackTrace();
        }
    }
}
